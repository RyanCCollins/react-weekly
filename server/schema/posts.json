{"posts": [{"title": "Relay/GraphQL On Rails", "image": "1*ml4H68gOogx8uCYqhfUNSA.png", "tags": [{"virtuals": {"isFollowing": false}, "name": "Rails", "postCount": 807, "type": "Tag", "slug": "rails", "metadata": {"followerCount": 543, "coverImage": {"id": "1*w5Rbsf5AmUbQxM8YCGFQPQ.jpeg", "originalWidth": 649, "originalHeight": 210}, "postCount": 807}}, {"virtuals": {"isFollowing": false}, "name": "Relayjs", "postCount": 10, "type": "Tag", "slug": "relayjs", "metadata": {"followerCount": 11, "coverImage": {"id": "1*JpHI9Z6-REqFjXlovPSSwQ.png", "originalWidth": 991, "originalHeight": 398}, "postCount": 10}}, {"virtuals": {"isFollowing": false}, "name": "Graphql", "postCount": 163, "type": "Tag", "slug": "graphql", "metadata": {"followerCount": 550, "coverImage": {"isFeatured": true, "id": "1*aBp8M-GPgIiRXVVL6fkyjA.png", "originalWidth": 936, "originalHeight": 765}, "postCount": 163}}], "snippet": "Summary: If you are excited about just declaring data required by your UI components while leaving the difficult parts of data fetching\u2026, updating, and data handling performance issues to a framework, you will be excited by Facebook\u2019s recent release of Relay/RelayJS (Sep 2015), which works with React UI (Oct 2014). This article shows you how to to integrate Relay/React into Rails.\n\nNOTE:\n\nYou can clone this starter-kit from Github, and start using Relay immediately without reading further\n\nConversely, with instructions here you can re-created the starter-kit on Github\n\nFacebook introduced React (Oct 2014) to make creating rich\u2026", "uniqueSlug": "relay-facebook-on-rails-8b4af2057152", "recommendations": [], "id": "8b4af2057152"}, {"title": "Never `import React from \u2018react\u2019` again, thanks to Webpack\u2019s ProvidePlugin", "image": "", "tags": [{"virtuals": {"isFollowing": false}, "name": "JavaScript", "postCount": 15241, "type": "Tag", "slug": "javascript", "metadata": {"followerCount": 16921, "coverImage": {"id": "1*AM83LP9sGGjIul3c5hIsWg.png", "originalWidth": 5100, "originalHeight": 2264}, "postCount": 15241}}, {"virtuals": {"isFollowing": false}, "name": "React", "postCount": 2971, "type": "Tag", "slug": "react", "metadata": {"followerCount": 5912, "coverImage": {"isFeatured": true, "id": "1*aBp8M-GPgIiRXVVL6fkyjA.png", "originalWidth": 936, "originalHeight": 765}, "postCount": 2971}}, {"virtuals": {"isFollowing": false}, "name": "Webpack", "postCount": 330, "type": "Tag", "slug": "webpack", "metadata": {"followerCount": 604, "coverImage": {"id": "1*zA-2-y8NzGLPB2VKillRqQ.png", "originalWidth": 500, "originalHeight": 500}, "postCount": 330}}], "snippet": "How many times a day do you write this import statement?Or this guy?\n\nA few weeks ago, a colleague at Udacity showed me a trick that eliminates the need for repetitive import statements in your code. The magic starts on line 18, with Webpack\u2019s ProvidePlugin:\n\nWhen Webpack builds your JavaScript, it will load the \u2018react\u2019 module whenever the identifier \u2018React\u2019 is declared in your code. So now you can use:\n\n\u2026without having to import \u2018react\u2019 explicitly at the top of your component file.", "uniqueSlug": "never-import-react-from-react-again-thanks-to-webpack-s-provideplugin-69e7feb69e", "recommendations": [], "id": "69e7feb69e"}, {"title": "Building a React & MobX application with MVVM", "image": "1*gDZgHB7KYr44WG442p5BBw.png", "tags": [{"virtuals": {"isFollowing": false}, "name": "Webpack", "postCount": 330, "type": "Tag", "slug": "webpack", "metadata": {"followerCount": 604, "coverImage": {"id": "1*zA-2-y8NzGLPB2VKillRqQ.png", "originalWidth": 500, "originalHeight": 500}, "postCount": 330}}, {"virtuals": {"isFollowing": false}, "name": "JavaScript", "postCount": 15241, "type": "Tag", "slug": "javascript", "metadata": {"followerCount": 16921, "coverImage": {"id": "1*AM83LP9sGGjIul3c5hIsWg.png", "originalWidth": 5100, "originalHeight": 2264}, "postCount": 15241}}, {"virtuals": {"isFollowing": false}, "name": "Mobx", "postCount": 22, "type": "Tag", "slug": "mobx", "metadata": {"followerCount": 46, "coverImage": {"id": "1*gDZgHB7KYr44WG442p5BBw.png", "originalWidth": 823, "originalHeight": 386}, "postCount": 22}}, {"virtuals": {"isFollowing": false}, "name": "Babeljs", "postCount": 66, "type": "Tag", "slug": "babeljs", "metadata": {"followerCount": 154, "coverImage": {"id": "1*5rhtsSpxx8iL1Gm8FnG0YA.jpeg", "originalWidth": 2133, "originalHeight": 1600}, "postCount": 66}}, {"virtuals": {"isFollowing": false}, "name": "React", "postCount": 2971, "type": "Tag", "slug": "react", "metadata": {"followerCount": 5912, "coverImage": {"isFeatured": true, "id": "1*aBp8M-GPgIiRXVVL6fkyjA.png", "originalWidth": 936, "originalHeight": 765}, "postCount": 2971}}], "snippet": "Today, we\u2019ll deep dive into building a full TodoEditor with MobX and React, starting from the basics and ending with some considerations.Here you\u2019ll find the entire code repo! \nhttps://github.com/mattiamanzati/react-mobx-todo-editor\n\nFinding a JavaScript editor\n\nFirst of all, you will obviously need any text editor to edit your JavaScript code. I recommend using VSCode, an OpenSource JavaScript editor supported by Microsoft. Give it a shoot, it\u2019s great!\n\nSetting up the build environment\n\nSetting up the full stack build environment for a React application could be tedious, but fortunately facebook published a create-react-app\u2026", "uniqueSlug": "building-a-react-mobx-application-with-mvvm-ec0b3e3c8786", "recommendations": [], "id": "ec0b3e3c8786"}, {"title": "Is React.js fast?\nFaster than {framework}?\n\u2026 or are there more relevant questions to be asking?", "image": "1*Qmhtum3UG8KqFTnr6EsuDw.jpeg", "tags": [{"virtuals": {"isFollowing": false}, "name": "Reactjs", "postCount": 420, "type": "Tag", "slug": "reactjs", "metadata": {"followerCount": 2055, "coverImage": {"id": "1*W7JKn48kJARmaWgeGTk5UA.png", "originalWidth": 1842, "originalHeight": 578}, "postCount": 420}}, {"virtuals": {"isFollowing": false}, "name": "JavaScript", "postCount": 15241, "type": "Tag", "slug": "javascript", "metadata": {"followerCount": 16921, "coverImage": {"id": "1*AM83LP9sGGjIul3c5hIsWg.png", "originalWidth": 5100, "originalHeight": 2264}, "postCount": 15241}}, {"virtuals": {"isFollowing": false}, "name": "React", "postCount": 2971, "type": "Tag", "slug": "react", "metadata": {"followerCount": 5912, "coverImage": {"isFeatured": true, "id": "1*aBp8M-GPgIiRXVVL6fkyjA.png", "originalWidth": 936, "originalHeight": 765}, "postCount": 2971}}], "snippet": "I give training in React.js via CodeWinds, and one of the questions I\u2019m often asked is whether it is faster than X?The short answer is that React.js is very performant out of the box, even before you start tweaking.\n\nNote that performance is always a tradeoff and one needs to be careful to optimize real use cases (e.g. time to render moderately complex screen) instead of artificial benchmarks (reorder 1000 items).\n\nEven so, React.js has a great performance story. Its component model lets you easily optimize performance bottlenecks without changing the components\u2019 interface.", "uniqueSlug": "is-react-js-fast-faster-than-framework-or-are-there-more-relevant-questions-to-be-asking-bcf40211f89b", "recommendations": [], "id": "bcf40211f89b"}, {"title": "Code Chunking with Webpack \u2014 A pragmatic approach", "image": "1*s7zJmbewKLwHfGnyxQleCw.jpeg", "tags": [{"virtuals": {"isFollowing": false}, "name": "JavaScript", "postCount": 15241, "type": "Tag", "slug": "javascript", "metadata": {"followerCount": 16921, "coverImage": {"id": "1*AM83LP9sGGjIul3c5hIsWg.png", "originalWidth": 5100, "originalHeight": 2264}, "postCount": 15241}}, {"virtuals": {"isFollowing": false}, "name": "React", "postCount": 2971, "type": "Tag", "slug": "react", "metadata": {"followerCount": 5912, "coverImage": {"isFeatured": true, "id": "1*aBp8M-GPgIiRXVVL6fkyjA.png", "originalWidth": 936, "originalHeight": 765}, "postCount": 2971}}, {"virtuals": {"isFollowing": false}, "name": "Webpack", "postCount": 330, "type": "Tag", "slug": "webpack", "metadata": {"followerCount": 604, "coverImage": {"id": "1*zA-2-y8NzGLPB2VKillRqQ.png", "originalWidth": 500, "originalHeight": 500}, "postCount": 330}}, {"virtuals": {"isFollowing": false}, "name": "Chunking", "postCount": 6, "type": "Tag", "slug": "chunking", "metadata": {"followerCount": 0, "coverImage": {"id": "1*s7zJmbewKLwHfGnyxQleCw.jpeg", "originalWidth": 852, "originalHeight": 563}, "postCount": 6}}, {"virtuals": {"isFollowing": false}, "name": "Code", "postCount": 1374, "type": "Tag", "slug": "code", "metadata": {"followerCount": 560, "coverImage": {"id": "1*jbeYLiJhW35J_glQCXmHhQ.jpeg", "originalWidth": 1680, "originalHeight": 1050}, "postCount": 1374}}], "snippet": "Ever since the inception of client side JS taking control of the web, we have observed a hefty amount of JS being written or included in\u2026our web apps. Gone are the times when our servers used to render the html for our web apps (although they\u2019re used for initial server side rendering). Today we need more out of our web apps like lazy loading of data through Ajax, cool animations, app state management, routing, infinite scrolling and many more.\n\nAll of these things mentioned require a decent amount of work on JavaScript by a front-end developer.", "uniqueSlug": "code-chunking-with-webpack-a-pragmatic-approach-e17e8bcc6453", "recommendations": [], "id": "e17e8bcc6453"}, {"title": "Embracing Immutable Architecture", "image": "1*De-cn--751z3cHRlMiXJDw.png", "tags": [{"virtuals": {"isFollowing": false}, "name": "JavaScript", "postCount": 15241, "type": "Tag", "slug": "javascript", "metadata": {"followerCount": 16921, "coverImage": {"id": "1*AM83LP9sGGjIul3c5hIsWg.png", "originalWidth": 5100, "originalHeight": 2264}, "postCount": 15241}}, {"virtuals": {"isFollowing": false}, "name": "React", "postCount": 2971, "type": "Tag", "slug": "react", "metadata": {"followerCount": 5912, "coverImage": {"isFeatured": true, "id": "1*aBp8M-GPgIiRXVVL6fkyjA.png", "originalWidth": 936, "originalHeight": 765}, "postCount": 2971}}, {"virtuals": {"isFollowing": false}, "name": "Immutable Infrastructure", "postCount": 5, "type": "Tag", "slug": "immutable-infrastructure", "metadata": {"followerCount": 3, "coverImage": {"id": "1*X9QHbRm4Zc0DRPd3FyygkA.png", "originalWidth": 2454, "originalHeight": 852}, "postCount": 5}}, {"virtuals": {"isFollowing": false}, "name": "Functional Programming", "postCount": 1009, "type": "Tag", "slug": "functional-programming", "metadata": {"followerCount": 2674, "coverImage": {"id": "1*AM83LP9sGGjIul3c5hIsWg.png", "originalWidth": 5100, "originalHeight": 2264}, "postCount": 1009}}], "snippet": "I believe as a community, many of us JavaScript engineers have embraced Immutable Architecture. Whether we realize it or not, a new way of\u2026building apps has crept into the mainstream JavaScript ecosystem and it is here to stay.\n\nWhat is Immutable Architecture, anyways?\n\nTo understand immutable architecture, we need to first understand state. State, an evil source of complexity in any software, is the characteristic of a value. According to Miriam Webster, state is defined as \u201cthe particular condition that someone or something is in at a specific time.\u201d", "uniqueSlug": "embracing-immutable-architecture-dc04e3f08543", "recommendations": [], "id": "dc04e3f08543"}]}